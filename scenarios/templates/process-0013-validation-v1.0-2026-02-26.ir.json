{
  "v": "1.0",
  "id": "process-0013",
  "name": "PROCESS-0013 Quality Validation",
  "description": "3-phase validation: Coverage, SPEC fidelity, TASK fidelity with traceability",
  "domain": "quality-assurance",
  "category": "templates",
  "tags": ["validation", "quality", "traceability", "coverage"],
  "_comment_inputs": "Expected context variables at runtime",
  "params": [
    { "id": "user_spec", "t": "str", "def": "" },
    { "id": "branch", "t": "str", "def": "main" },
    { "id": "model", "t": "str", "def": "sonnet" },
    { "id": "task_id", "t": "str", "def": "" },
    { "id": "assignment_file", "t": "str", "def": "" },
    { "id": "spec_file", "t": "str", "def": "" },
    { "id": "tasks_file", "t": "str", "def": "" }
  ],
  "context_init": {
    "gate0_retries": 0,
    "phase0_retries": 0,
    "phase1_retries": 0,
    "phase2_retries": 0,
    "max_retries": 3
  },
  "nodes": [
    {
      "id": "start",
      "t": "start",
      "name": "Start Validation Process",
      "pos": { "x": 100, "y": 100 }
    },
    {
      "id": "generate-assignment",
      "t": "task",
      "name": "Generate ASSIGNMENT from Spec",
      "o": {
        "op": "llm",
        "tier": 2,
        "prompt": "Convert user spec into formal ASSIGNMENT with requirements. Extract all requirements as:\n- REQ-{CATEGORY}-{NNN} format\n- Each requirement must have: id, type (user_story/technical/constraint), category (UI/Backend/Security/etc), description, acceptance criteria, mandatory (true/false)\n\nUser Spec:\n{{user_spec}}\n\nOutput formal ASSIGNMENT in markdown with numbered requirements.",
        "required": true
      },
      "out": "assignment_text",
      "pos": { "x": 100, "y": 200 }
    },
    {
      "id": "save-assignment",
      "t": "task",
      "name": "Save ASSIGNMENT to File",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import sys; open('{{assignment_file}}', 'w', encoding='utf-8').write(sys.stdin.read())\" <<< '{{assignment_text}}'",
        "scriptTimeout": 5000
      },
      "pos": { "x": 100, "y": 300 }
    },
    {
      "id": "generate-spec",
      "t": "task",
      "name": "Generate SPEC with Traceability",
      "o": {
        "op": "llm",
        "tier": 2,
        "prompt": "Write detailed SPEC with traceability IDs for:\n\n{{assignment_text}}\n\nEach SPEC item must:\n- Have ID: SPEC-{NNN}\n- Reference requirement: **Implements:** REQ-{CAT}-{NNN}\n- Include category, description, acceptance criteria\n- Follow markdown format with headers\n\nOutput complete SPEC in markdown.",
        "required": true
      },
      "out": "spec_text",
      "pos": { "x": 100, "y": 400 }
    },
    {
      "id": "save-spec",
      "t": "task",
      "name": "Save SPEC to File",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import sys; open('{{spec_file}}', 'w', encoding='utf-8').write(sys.stdin.read())\" <<< '{{spec_text}}'",
        "scriptTimeout": 5000
      },
      "pos": { "x": 100, "y": 500 }
    },
    {
      "id": "gate0-validate",
      "t": "task",
      "name": "Gate 0: Validate Requirements Trees",
      "o": {
        "op": "script",
        "scriptCommand": "python -m simdecisions.qce.tree_compare compare --user-prompt '{{user_spec}}' --spec-text '{{spec_text}}'",
        "scriptTimeout": 30000
      },
      "out": "gate0_result_json",
      "pos": { "x": 100, "y": 550 }
    },
    {
      "id": "gate0-check-retry",
      "t": "decision",
      "name": "Gate 0 Pass?",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import json; r=json.loads('{{gate0_result_json}}'); exit(0 if r.get('passed') else 1)\""
      },
      "pos": { "x": 100, "y": 575 }
    },
    {
      "id": "gate0-check-max-retries",
      "t": "decision",
      "name": "Gate 0 Max Retries?",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"gate0_retries = int('{{gate0_retries}}'); exit(0 if gate0_retries < 3 else 1)\""
      },
      "pos": { "x": 300, "y": 575 }
    },
    {
      "id": "gate0-heal",
      "t": "task",
      "name": "Gate 0: Heal SPEC",
      "o": {
        "op": "llm",
        "tier": 2,
        "prompt": "Gate 0 validation failed. Your SPEC doesn't match the user's prompt.\n\nUser prompt:\n{{user_spec}}\n\nDiagnostic:\n{{gate0_result_json}}\n\nRegenerate SPEC that:\n1. Includes ALL requirements from user prompt\n2. Does NOT add requirements user didn't ask for\n3. Preserves requirement hierarchy\n4. Achieves 100% coverage\n\nUse the same format as before with traceability IDs (SPEC-NNN, REQ-CAT-NNN).",
        "required": true
      },
      "out": "spec_text",
      "pos": { "x": 300, "y": 625 }
    },
    {
      "id": "save-spec-retry",
      "t": "task",
      "name": "Save Healed SPEC",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import sys, json; open('{{spec_file}}', 'w', encoding='utf-8').write(sys.stdin.read()); gate0_retries = int('{{gate0_retries}}') + 1; print(json.dumps({'gate0_retries': gate0_retries}))\" <<< '{{spec_text}}'",
        "scriptTimeout": 5000
      },
      "out": "retry_update",
      "pos": { "x": 300, "y": 675 }
    },
    {
      "id": "gate0-escalate",
      "t": "task",
      "name": "Gate 0: Escalate to Human",
      "o": {
        "op": "human",
        "prompt": "Gate 0 failed after 3 retries. Manual intervention needed.\n\nUser prompt:\n{{user_spec}}\n\nGenerated SPEC:\n{{spec_text}}\n\nDiagnostic:\n{{gate0_result_json}}\n\nPlease review and either:\n1. Type 'approve' to override validation\n2. Type 'edited' after manually editing SPEC\n3. Type 'abort' to stop the task",
        "required": true
      },
      "out": "human_decision",
      "pos": { "x": 500, "y": 575 }
    },
    {
      "id": "gate0-human-decision",
      "t": "decision",
      "name": "Human Approved?",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"decision = '{{human_decision}}'.lower().strip(); exit(0 if decision in ['approve', 'approved', 'edited'] else 1)\""
      },
      "pos": { "x": 500, "y": 625 }
    },
    {
      "id": "fail-gate0",
      "t": "end",
      "name": "Gate 0 Failed",
      "out": {
        "status": "failed",
        "gate": "gate0",
        "error": "Gate 0 validation failed and was aborted by human: {{gate0_result_json}}"
      },
      "pos": { "x": 500, "y": 700 }
    },
    {
      "id": "phase0-extract-requirements",
      "t": "task",
      "name": "Phase 0: Extract Requirements",
      "o": {
        "op": "llm",
        "tier": 0,
        "prompt": "Extract all requirements from ASSIGNMENT as JSON array.\n\nAssignment:\n{{assignment_text}}\n\nFor each requirement, provide:\n{\n  \"id\": \"REQ-{CATEGORY}-{NNN}\",\n  \"type\": \"user_story|technical|constraint\",\n  \"category\": \"UI|Backend|Security|etc\",\n  \"description\": \"what is required\",\n  \"acceptance\": \"how to verify\",\n  \"mandatory\": true|false\n}\n\nOutput ONLY valid JSON array, no markdown or explanation."
      },
      "out": "requirements_json",
      "pos": { "x": 100, "y": 600 }
    },
    {
      "id": "phase0-check-coverage",
      "t": "task",
      "name": "Phase 0: Check Coverage",
      "o": {
        "op": "llm",
        "tier": 0,
        "prompt": "For each requirement, check if it's covered in SPEC.\n\nRequirements:\n{{requirements_json}}\n\nSPEC:\n{{spec_text}}\n\nFor each requirement respond with JSON:\n{\n  \"requirements\": [\n    {\n      \"id\": \"REQ-XXX-NNN\",\n      \"status\": \"COVERED|PARTIAL|MISSING|OUT_OF_SCOPE\",\n      \"location\": \"line number or section\",\n      \"evidence\": \"quoted text showing coverage\",\n      \"confidence\": 0.0-1.0\n    }\n  ],\n  \"coverage_score\": 0.0-1.0,\n  \"violations\": [\"list of mandatory requirements declared out of scope\"],\n  \"message\": \"summary message\"\n}\n\nOutput ONLY valid JSON, no markdown."
      },
      "out": "coverage_report_json",
      "pos": { "x": 100, "y": 700 }
    },
    {
      "id": "phase0-decision",
      "t": "decision",
      "name": "Phase 0 Pass?",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import json; r=json.loads('{{coverage_report_json}}'); exit(0 if r.get('coverage_score')==1.0 and len(r.get('violations',[]))==0 else 1)\""
      },
      "pos": { "x": 100, "y": 800 }
    },
    {
      "id": "phase0-check-max-retries",
      "t": "decision",
      "name": "Phase 0 Max Retries?",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"phase0_retries = int('{{phase0_retries}}'); exit(0 if phase0_retries < 3 else 1)\""
      },
      "pos": { "x": 300, "y": 825 }
    },
    {
      "id": "phase0-heal",
      "t": "task",
      "name": "Phase 0: Heal SPEC Coverage",
      "o": {
        "op": "llm",
        "tier": 2,
        "prompt": "Phase 0 coverage validation failed. Your SPEC is missing requirements from the ASSIGNMENT.\n\nASSIGNMENT:\n{{assignment_text}}\n\nCurrent SPEC:\n{{spec_text}}\n\nCoverage Report:\n{{coverage_report_json}}\n\nRegenerate SPEC that:\n1. Includes ALL missing requirements from the coverage report\n2. Preserves existing coverage that passed\n3. Achieves 100% coverage with 0 violations\n4. Uses the same format with traceability IDs (SPEC-NNN, REQ-CAT-NNN)",
        "required": true
      },
      "out": "spec_text",
      "pos": { "x": 300, "y": 875 }
    },
    {
      "id": "save-spec-phase0-retry",
      "t": "task",
      "name": "Save Healed SPEC (Phase 0)",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import sys, json; open('{{spec_file}}', 'w', encoding='utf-8').write(sys.stdin.read()); phase0_retries = int('{{phase0_retries}}') + 1; print(json.dumps({'phase0_retries': phase0_retries}))\" <<< '{{spec_text}}'",
        "scriptTimeout": 5000
      },
      "out": "retry_update_phase0",
      "pos": { "x": 300, "y": 925 }
    },
    {
      "id": "phase0-escalate",
      "t": "task",
      "name": "Phase 0: Escalate to Human",
      "o": {
        "op": "human",
        "prompt": "Phase 0 coverage validation failed after 3 retries. Manual intervention needed.\n\nASSIGNMENT:\n{{assignment_text}}\n\nGenerated SPEC:\n{{spec_text}}\n\nCoverage Report:\n{{coverage_report_json}}\n\nPlease review and either:\n1. Type 'approve' to override validation\n2. Type 'edited' after manually editing SPEC\n3. Type 'abort' to stop the task",
        "required": true
      },
      "out": "human_decision_phase0",
      "pos": { "x": 500, "y": 825 }
    },
    {
      "id": "phase0-human-decision",
      "t": "decision",
      "name": "Human Approved Phase 0?",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"decision = '{{human_decision_phase0}}'.lower().strip(); exit(0 if decision in ['approve', 'approved', 'edited'] else 1)\""
      },
      "pos": { "x": 500, "y": 875 }
    },
    {
      "id": "save-phase0-report",
      "t": "task",
      "name": "Save Phase 0 Report",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import json, sys; from datetime import datetime; r=json.loads('{{coverage_report_json}}'); status='PASS' if r.get('coverage_score')==1.0 and len(r.get('violations',[]))==0 else 'FAIL'; report=f'''# Phase 0: Coverage Validation\\n\\n## Summary\\n- Total Requirements: {len(r.get('requirements',[]))}\\n- Coverage Score: {r.get('coverage_score')}\\n- Violations: {len(r.get('violations',[]))}\\n\\n## Status: {status}\\n\\n## Message\\n{r.get('message')}\\n\\n## Details\\n{json.dumps(r, indent=2)}\\n'''; ts=datetime.now().strftime('%Y-%m-%d-%H%M'); open(f'.deia/hive/responses/{ts}-RAILWAY-{{task_id}}-PHASE0-REPORT.md', 'w').write(report)\""
      },
      "pos": { "x": 300, "y": 800 }
    },
    {
      "id": "fail-phase0",
      "t": "end",
      "name": "Phase 0 Failed",
      "out": {
        "status": "failed",
        "phase": "phase0",
        "error": "Coverage validation failed: {{coverage_report_json}}"
      },
      "pos": { "x": 100, "y": 900 }
    },
    {
      "id": "phase1-encode-spec",
      "t": "task",
      "name": "Phase 1: Encode SPEC to IR",
      "o": {
        "op": "llm",
        "tier": 2,
        "prompt": "Convert SPEC to PHASE-IR format (JSON compact format).\n\nSPEC:\n{{spec_text}}\n\nConvert to IR following PHASE-IR v1.0 schema:\n- nodes: array of {id, t (type), name, o (oracle), out}\n- edges: array of {s (source), t (target), c (condition)}\n\nOutput ONLY valid JSON IR, no markdown or explanation."
      },
      "out": "spec_ir_json",
      "pos": { "x": 500, "y": 700 }
    },
    {
      "id": "phase1-decode-spec",
      "t": "task",
      "name": "Phase 1: Decode IR to SPEC'",
      "o": {
        "op": "llm",
        "tier": 2,
        "prompt": "Convert IR back to English SPEC.\n\nIR:\n{{spec_ir_json}}\n\nConvert this IR back to a human-readable specification document in markdown format. Preserve all semantic meaning from the IR structure.\n\nOutput ONLY the specification document, no additional commentary."
      },
      "out": "spec_prime",
      "pos": { "x": 500, "y": 800 }
    },
    {
      "id": "phase1-compare",
      "t": "task",
      "name": "Phase 1: Compare Fidelity",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"from sklearn.feature_extraction.text import TfidfVectorizer; from sklearn.metrics.pairwise import cosine_similarity; import json; orig='{{spec_text}}'; prime='{{spec_prime}}'; vectorizer = TfidfVectorizer(); tfidf = vectorizer.fit_transform([orig, prime]); similarity = float(cosine_similarity(tfidf[0:1], tfidf[1:2])[0][0]); print(json.dumps({'fidelity': similarity, 'threshold': 0.85, 'passed': similarity >= 0.85}))\""
      },
      "out": "spec_fidelity_json",
      "pos": { "x": 500, "y": 900 }
    },
    {
      "id": "phase1-decision",
      "t": "decision",
      "name": "Phase 1 Pass?",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import json; r=json.loads('{{spec_fidelity_json}}'); exit(0 if r.get('passed') else 1)\""
      },
      "pos": { "x": 500, "y": 1000 }
    },
    {
      "id": "phase1-check-max-retries",
      "t": "decision",
      "name": "Phase 1 Max Retries?",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"phase1_retries = int('{{phase1_retries}}'); exit(0 if phase1_retries < 3 else 1)\""
      },
      "pos": { "x": 700, "y": 1025 }
    },
    {
      "id": "phase1-heal",
      "t": "task",
      "name": "Phase 1: Heal SPEC Fidelity",
      "o": {
        "op": "llm",
        "tier": 2,
        "prompt": "Phase 1 SPEC fidelity validation failed. The round-trip SPEC→IR→SPEC' lost semantic meaning.\n\nOriginal SPEC:\n{{spec_text}}\n\nReconstructed SPEC':\n{{spec_prime}}\n\nFidelity Score: {{spec_fidelity_json}}\n\nRegenerate SPEC that:\n1. Preserves all semantic meaning when encoded to IR\n2. Uses clear, unambiguous language\n3. Makes relationships and dependencies explicit\n4. Achieves fidelity ≥ 0.85\n5. Uses the same format with traceability IDs",
        "required": true
      },
      "out": "spec_text",
      "pos": { "x": 700, "y": 1075 }
    },
    {
      "id": "save-spec-phase1-retry",
      "t": "task",
      "name": "Save Healed SPEC (Phase 1)",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import sys, json; open('{{spec_file}}', 'w', encoding='utf-8').write(sys.stdin.read()); phase1_retries = int('{{phase1_retries}}') + 1; print(json.dumps({'phase1_retries': phase1_retries}))\" <<< '{{spec_text}}'",
        "scriptTimeout": 5000
      },
      "out": "retry_update_phase1",
      "pos": { "x": 700, "y": 1125 }
    },
    {
      "id": "phase1-escalate",
      "t": "task",
      "name": "Phase 1: Escalate to Human",
      "o": {
        "op": "human",
        "prompt": "Phase 1 SPEC fidelity validation failed after 3 retries. Manual intervention needed.\n\nOriginal SPEC:\n{{spec_text}}\n\nReconstructed SPEC':\n{{spec_prime}}\n\nFidelity Report:\n{{spec_fidelity_json}}\n\nPlease review and either:\n1. Type 'approve' to override validation\n2. Type 'edited' after manually editing SPEC\n3. Type 'abort' to stop the task",
        "required": true
      },
      "out": "human_decision_phase1",
      "pos": { "x": 900, "y": 1025 }
    },
    {
      "id": "phase1-human-decision",
      "t": "decision",
      "name": "Human Approved Phase 1?",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"decision = '{{human_decision_phase1}}'.lower().strip(); exit(0 if decision in ['approve', 'approved', 'edited'] else 1)\""
      },
      "pos": { "x": 900, "y": 1075 }
    },
    {
      "id": "save-phase1-report",
      "t": "task",
      "name": "Save Phase 1 Report",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import json; from datetime import datetime; r=json.loads('{{spec_fidelity_json}}'); status='PASS' if r.get('passed') else 'FAIL'; report=f'''# Phase 1: SPEC Fidelity Validation\\n\\n**Fidelity:** {r.get('fidelity')}\\n**Threshold:** {r.get('threshold')}\\n**Status:** {status}\\n\\n## Details\\n{json.dumps(r, indent=2)}\\n'''; ts=datetime.now().strftime('%Y-%m-%d-%H%M'); open(f'.deia/hive/responses/{ts}-RAILWAY-{{task_id}}-PHASE1-REPORT.md', 'w').write(report)\""
      },
      "pos": { "x": 700, "y": 1000 }
    },
    {
      "id": "fail-phase1",
      "t": "end",
      "name": "Phase 1 Failed",
      "out": {
        "status": "failed",
        "phase": "phase1",
        "error": "SPEC fidelity validation failed: {{spec_fidelity_json}}"
      },
      "pos": { "x": 500, "y": 1100 }
    },
    {
      "id": "generate-tasks",
      "t": "task",
      "name": "Generate TASKS with Traceability",
      "o": {
        "op": "llm",
        "tier": 2,
        "prompt": "Break SPEC into implementation tasks with traceability.\n\nSPEC:\n{{spec_text}}\n\nCreate tasks following format:\n## TASK-{NNN}: {Title}\n**ID:** TASK-{NNN}\n**Implements:** SPEC-{NNN}\n**Satisfies:** REQ-{CAT}-{NNN}\n**Assignee:** {model tier}\n**Complexity:** Simple|Medium|Complex\n\n{Description}\n\n### Files to Create/Modify\n- path/to/file.ext\n\n### Dependencies\n- TASK-{NNN} (if any)\n\nOutput complete TASKS document in markdown.",
        "required": true
      },
      "out": "tasks_text",
      "pos": { "x": 900, "y": 900 }
    },
    {
      "id": "save-tasks",
      "t": "task",
      "name": "Save TASKS to File",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import sys; open('{{tasks_file}}', 'w', encoding='utf-8').write(sys.stdin.read())\" <<< '{{tasks_text}}'",
        "scriptTimeout": 5000
      },
      "pos": { "x": 900, "y": 1000 }
    },
    {
      "id": "phase2-encode-tasks",
      "t": "task",
      "name": "Phase 2: Encode TASKS to IR",
      "o": {
        "op": "llm",
        "tier": 2,
        "prompt": "Convert TASKS to PHASE-IR format.\n\nTASKS:\n{{tasks_text}}\n\nConvert to IR following PHASE-IR v1.0 schema. Each task becomes a node with dependencies as edges.\n\nOutput ONLY valid JSON IR, no markdown."
      },
      "out": "tasks_ir_json",
      "pos": { "x": 900, "y": 1100 }
    },
    {
      "id": "phase2-decode-tasks",
      "t": "task",
      "name": "Phase 2: Decode IR to TASKS'",
      "o": {
        "op": "llm",
        "tier": 2,
        "prompt": "Convert IR back to English TASKS document.\n\nIR:\n{{tasks_ir_json}}\n\nConvert this IR back to a human-readable tasks document in markdown format. Preserve all task structure and dependencies.\n\nOutput ONLY the tasks document."
      },
      "out": "tasks_prime",
      "pos": { "x": 900, "y": 1200 }
    },
    {
      "id": "phase2-compare",
      "t": "task",
      "name": "Phase 2: Compare Fidelity",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"from sklearn.feature_extraction.text import TfidfVectorizer; from sklearn.metrics.pairwise import cosine_similarity; import json; orig='{{tasks_text}}'; prime='{{tasks_prime}}'; vectorizer = TfidfVectorizer(); tfidf = vectorizer.fit_transform([orig, prime]); similarity = float(cosine_similarity(tfidf[0:1], tfidf[1:2])[0][0]); print(json.dumps({'fidelity': similarity, 'threshold': 0.85, 'passed': similarity >= 0.85}))\""
      },
      "out": "tasks_fidelity_json",
      "pos": { "x": 900, "y": 1300 }
    },
    {
      "id": "phase2-decision",
      "t": "decision",
      "name": "Phase 2 Pass?",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import json; r=json.loads('{{tasks_fidelity_json}}'); exit(0 if r.get('passed') else 1)\""
      },
      "pos": { "x": 900, "y": 1400 }
    },
    {
      "id": "phase2-check-max-retries",
      "t": "decision",
      "name": "Phase 2 Max Retries?",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"phase2_retries = int('{{phase2_retries}}'); exit(0 if phase2_retries < 3 else 1)\""
      },
      "pos": { "x": 1100, "y": 1425 }
    },
    {
      "id": "phase2-heal",
      "t": "task",
      "name": "Phase 2: Heal TASK Fidelity",
      "o": {
        "op": "llm",
        "tier": 2,
        "prompt": "Phase 2 TASK fidelity validation failed. The round-trip TASKS→IR→TASKS' lost semantic meaning.\n\nOriginal TASKS:\n{{tasks_text}}\n\nReconstructed TASKS':\n{{tasks_prime}}\n\nFidelity Score: {{tasks_fidelity_json}}\n\nRegenerate TASKS that:\n1. Preserves all dependencies and relationships\n2. Makes task ordering explicit\n3. Preserves all implementation details\n4. Achieves fidelity ≥ 0.85\n5. Uses the same format with traceability IDs (TASK-NNN, SPEC-NNN, REQ-CAT-NNN)",
        "required": true
      },
      "out": "tasks_text",
      "pos": { "x": 1100, "y": 1475 }
    },
    {
      "id": "save-tasks-phase2-retry",
      "t": "task",
      "name": "Save Healed TASKS (Phase 2)",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import sys, json; open('{{tasks_file}}', 'w', encoding='utf-8').write(sys.stdin.read()); phase2_retries = int('{{phase2_retries}}') + 1; print(json.dumps({'phase2_retries': phase2_retries}))\" <<< '{{tasks_text}}'",
        "scriptTimeout": 5000
      },
      "out": "retry_update_phase2",
      "pos": { "x": 1100, "y": 1525 }
    },
    {
      "id": "phase2-escalate",
      "t": "task",
      "name": "Phase 2: Escalate to Human",
      "o": {
        "op": "human",
        "prompt": "Phase 2 TASK fidelity validation failed after 3 retries. Manual intervention needed.\n\nOriginal TASKS:\n{{tasks_text}}\n\nReconstructed TASKS':\n{{tasks_prime}}\n\nFidelity Report:\n{{tasks_fidelity_json}}\n\nPlease review and either:\n1. Type 'approve' to override validation\n2. Type 'edited' after manually editing TASKS\n3. Type 'abort' to stop the task",
        "required": true
      },
      "out": "human_decision_phase2",
      "pos": { "x": 1300, "y": 1425 }
    },
    {
      "id": "phase2-human-decision",
      "t": "decision",
      "name": "Human Approved Phase 2?",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"decision = '{{human_decision_phase2}}'.lower().strip(); exit(0 if decision in ['approve', 'approved', 'edited'] else 1)\""
      },
      "pos": { "x": 1300, "y": 1475 }
    },
    {
      "id": "save-phase2-report",
      "t": "task",
      "name": "Save Phase 2 Report",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import json; from datetime import datetime; r=json.loads('{{tasks_fidelity_json}}'); status='PASS' if r.get('passed') else 'FAIL'; report=f'''# Phase 2: TASK Fidelity Validation\\n\\n**Fidelity:** {r.get('fidelity')}\\n**Threshold:** {r.get('threshold')}\\n**Status:** {status}\\n\\n## Details\\n{json.dumps(r, indent=2)}\\n'''; ts=datetime.now().strftime('%Y-%m-%d-%H%M'); open(f'.deia/hive/responses/{ts}-RAILWAY-{{task_id}}-PHASE2-REPORT.md', 'w').write(report)\""
      },
      "pos": { "x": 1100, "y": 1400 }
    },
    {
      "id": "fail-phase2",
      "t": "end",
      "name": "Phase 2 Failed",
      "out": {
        "status": "failed",
        "phase": "phase2",
        "error": "TASK fidelity validation failed: {{tasks_fidelity_json}}"
      },
      "pos": { "x": 900, "y": 1500 }
    },
    {
      "id": "dispatch-bees",
      "t": "split",
      "name": "Dispatch Worker Bees",
      "fan": "tasks_array",
      "_comment": "Split executes all task branches in parallel",
      "pos": { "x": 1300, "y": 1300 }
    },
    {
      "id": "parse-tasks",
      "t": "task",
      "name": "Parse Tasks for Dispatch",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import json, re; tasks='{{tasks_text}}'; pattern=r'## TASK-(\\\\d+):'; matches=re.findall(pattern, tasks); print(json.dumps([f'TASK-{m}' for m in matches]))\""
      },
      "out": "tasks_array",
      "pos": { "x": 1300, "y": 1200 }
    },
    {
      "id": "collect-bee-results",
      "t": "join",
      "name": "Collect Worker Results",
      "join": "all",
      "_comment": "Wait for all worker bees to complete",
      "pos": { "x": 1300, "y": 1400 }
    },
    {
      "id": "git-commit",
      "t": "task",
      "name": "Git Commit with Report",
      "o": {
        "op": "script",
        "scriptCommand": "python -c \"import json, subprocess; from datetime import datetime; phase0=json.loads('{{coverage_report_json}}'); phase1=json.loads('{{spec_fidelity_json}}'); phase2=json.loads('{{tasks_fidelity_json}}'); msg=f'''Railway Task {{task_id}}\\n\\nPhase 0: Coverage - PASS ({phase0.get('coverage_score')*100:.0f}% coverage)\\nPhase 1: SPEC Fidelity - PASS ({phase1.get('fidelity'):.4f})\\nPhase 2: TASK Fidelity - PASS ({phase2.get('fidelity'):.4f})\\n\\nUser Spec:\\n{{user_spec}}\\n\\nCo-Authored-By: Claude {{model}} <noreply@anthropic.com>'''; subprocess.run(['git', 'add', '.'], check=True); result=subprocess.run(['git', 'commit', '-m', msg], capture_output=True, text=True); sha=subprocess.check_output(['git', 'rev-parse', 'HEAD'], text=True).strip(); print(json.dumps({'commit_sha': sha, 'branch': '{{branch}}', 'message': msg}))\""
      },
      "out": "commit_result_json",
      "pos": { "x": 1300, "y": 1500 }
    },
    {
      "id": "end",
      "t": "end",
      "name": "Validation Complete",
      "out": {
        "status": "complete",
        "phase0": "{{coverage_report_json}}",
        "phase1": "{{spec_fidelity_json}}",
        "phase2": "{{tasks_fidelity_json}}",
        "commit": "{{commit_result_json}}"
      },
      "pos": { "x": 1300, "y": 1600 }
    }
  ],
  "edges": [
    { "s": "start", "t": "generate-assignment" },
    { "s": "generate-assignment", "t": "save-assignment" },
    { "s": "save-assignment", "t": "generate-spec" },
    { "s": "generate-spec", "t": "save-spec" },
    { "s": "save-spec", "t": "gate0-validate" },
    { "s": "gate0-validate", "t": "gate0-check-retry" },
    { "s": "gate0-check-retry", "t": "phase0-extract-requirements", "c": "passed" },
    { "s": "gate0-check-retry", "t": "gate0-check-max-retries", "c": "failed" },
    { "s": "gate0-check-max-retries", "t": "gate0-heal", "c": "retry" },
    { "s": "gate0-check-max-retries", "t": "gate0-escalate", "c": "escalate" },
    { "s": "gate0-heal", "t": "save-spec-retry" },
    { "s": "save-spec-retry", "t": "gate0-validate" },
    { "s": "gate0-escalate", "t": "gate0-human-decision" },
    { "s": "gate0-human-decision", "t": "phase0-extract-requirements", "c": "approved" },
    { "s": "gate0-human-decision", "t": "fail-gate0", "c": "abort" },
    { "s": "phase0-extract-requirements", "t": "phase0-check-coverage" },
    { "s": "phase0-check-coverage", "t": "phase0-decision" },
    { "s": "phase0-decision", "t": "save-phase0-report", "c": "passed" },
    { "s": "phase0-decision", "t": "phase0-check-max-retries", "c": "failed" },
    { "s": "phase0-check-max-retries", "t": "phase0-heal", "c": "retry" },
    { "s": "phase0-check-max-retries", "t": "phase0-escalate", "c": "escalate" },
    { "s": "phase0-heal", "t": "save-spec-phase0-retry" },
    { "s": "save-spec-phase0-retry", "t": "phase0-extract-requirements" },
    { "s": "phase0-escalate", "t": "phase0-human-decision" },
    { "s": "phase0-human-decision", "t": "save-phase0-report", "c": "approved" },
    { "s": "phase0-human-decision", "t": "fail-phase0", "c": "abort" },
    { "s": "save-phase0-report", "t": "phase1-encode-spec" },
    { "s": "phase1-encode-spec", "t": "phase1-decode-spec" },
    { "s": "phase1-decode-spec", "t": "phase1-compare" },
    { "s": "phase1-compare", "t": "phase1-decision" },
    { "s": "phase1-decision", "t": "save-phase1-report", "c": "passed" },
    { "s": "phase1-decision", "t": "phase1-check-max-retries", "c": "failed" },
    { "s": "phase1-check-max-retries", "t": "phase1-heal", "c": "retry" },
    { "s": "phase1-check-max-retries", "t": "phase1-escalate", "c": "escalate" },
    { "s": "phase1-heal", "t": "save-spec-phase1-retry" },
    { "s": "save-spec-phase1-retry", "t": "phase1-encode-spec" },
    { "s": "phase1-escalate", "t": "phase1-human-decision" },
    { "s": "phase1-human-decision", "t": "save-phase1-report", "c": "approved" },
    { "s": "phase1-human-decision", "t": "fail-phase1", "c": "abort" },
    { "s": "save-phase1-report", "t": "generate-tasks" },
    { "s": "generate-tasks", "t": "save-tasks" },
    { "s": "save-tasks", "t": "phase2-encode-tasks" },
    { "s": "phase2-encode-tasks", "t": "phase2-decode-tasks" },
    { "s": "phase2-decode-tasks", "t": "phase2-compare" },
    { "s": "phase2-compare", "t": "phase2-decision" },
    { "s": "phase2-decision", "t": "save-phase2-report", "c": "passed" },
    { "s": "phase2-decision", "t": "phase2-check-max-retries", "c": "failed" },
    { "s": "phase2-check-max-retries", "t": "phase2-heal", "c": "retry" },
    { "s": "phase2-check-max-retries", "t": "phase2-escalate", "c": "escalate" },
    { "s": "phase2-heal", "t": "save-tasks-phase2-retry" },
    { "s": "save-tasks-phase2-retry", "t": "phase2-encode-tasks" },
    { "s": "phase2-escalate", "t": "phase2-human-decision" },
    { "s": "phase2-human-decision", "t": "save-phase2-report", "c": "approved" },
    { "s": "phase2-human-decision", "t": "fail-phase2", "c": "abort" },
    { "s": "save-phase2-report", "t": "parse-tasks" },
    { "s": "parse-tasks", "t": "dispatch-bees" },
    { "s": "dispatch-bees", "t": "collect-bee-results" },
    { "s": "collect-bee-results", "t": "git-commit" },
    { "s": "git-commit", "t": "end" }
  ]
}
